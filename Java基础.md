# **Java基础**

## **Java和C++的区别?**

- 都是面向对象的语言，都支持封装、继承和多态

- Java 不提供指针来直接访问内存，程序内存更加安全

- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。

- Java 有自动内存管理机制，不需要程序员手动释放无用内存

- **在** **C** **语言中，字符串或字符数组最后都会有一个额外的字符****‘\0’****来表示结束。但是，****Java** **语言中没有结束符这一概念。**

  

## **Java有几种基本数据类型**

八种：**byte**,short,**long**,**int**,char,**float,double,boolean**

**基本类型和引用类型？他们的区别**

除了8中基本数据类型都是引用类型， 为了面向对象操作的一致性，每种数据类型都有对应的包装类。

**不同点**：

- 赋值方法不同，基本类型直接赋值，引用类型通过 new 创建对象，然后再把对象赋予相应的变量。
- 比较方面的不同，== 号的比较：引用类型比较的是引用地址，基本类型比较的是值
- 在数据做为参数传递的时候，基本数据类型是值传递，而引用数据类型是引用传递（地址传递）。
- **分别放在** **JVM** **的哪里？**

基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上（也不完全一定）。

而引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。



## **重载和重写的区别**

**重载**

发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

**重写**

重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。**也就是说方法提供的行为改变，而方法的外貌并没有改变。**





## **Java**面向对象编程三大特性: 封装 继承 多态

**封装**

把描述一个对象的属性和行为的代码封装在一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。

**继承**

子类继承父类的特征和行为。子类可以有父类非私有的方法，属性。子类也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高代码之间的耦合性。

**多态**

多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定(比如：向上转型，只有运行才能确定其对象属性)。方法覆盖和重载体现了多态性。





## **接口和抽象类的区别**

1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。





## **final** **在** **java** **中有什么作用？**

- final 修饰的类叫最终类，该类不能被继承。
- final 修饰的方法不能被重写。
- final 修饰的变量不可更改，**其不可更改指的是其引用不可修改，对于引用类型值还是可能改变的，举个列子：****String** **内部对于** **value** **的定义；而对于基本类型来说就叫做常量了。**

## **final,  finally, finalize有什么区别？**

- final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
- finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。



## **String StringBuffer** **和** StringBuilder

**线程安全**

StringBuilder是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低。

**性能**

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。

**数据可变和不可变**

1. String的值不可变的。
2. StringBuffer和StringBuilder的值是可变的，底层使用的是可变字符数组：char[]     value;

**使用场景**

- 如果需要操作少量的数据用 String
- 单线程操作字符串缓冲区的情况下操作大量数据使用 StringBuilder
- 多线程操作字符串缓冲区 下操作大量数据使用 StringBuffer



## **String** **是如何实现不可变的？**

首先要明确：**String** **不可变的是字符串的值不变。**

让我们看 String 源码：

private final char value[];

从源码来看, String 类内部是用 char 数组来保存字符串的值, 并且 char[] 是 final 的, 这里的 final 意味着什么呢?

- value 必须在构造时为其赋值
- 赋值后 value 的引用不能再变

当我们实例化一个 String 对象并得到其引用后, 构造已经结束了, 即 value 的引用已经不能再变了 。 那么 value 的值呢, 理论上是可以改变的, 只要我们拿到 value 的引用, 可以直接通过下标改变他的值 。

然而，因为 String 并没有提供接口来改变 value 的值，所以value 的值我们从 String 外部获取不到，也改变不了。这才是String 才是不可变的真正原因，并不仅仅是使用 final 修饰了 value 数据。

补充：然而，并不是真正的完全不能获取，利用反射可以直接获取类内部属性。

## **String** 为什么设置为不可变

- 为了实现字符串常量池(只有当字符是不可变的，字符串池才有可能实现)
- 为了线程安全(字符串自己便是线程安全的)
- 为了保证同一个对象调用 hashCode() 都产生相同的值，String 设置为不可变可以对这个条件有很好的支持，这也是 Map 类的 key 使用 String 的原因。

## 排序算法

![img](https://www.runoob.com/wp-content/uploads/2019/03/sort.png)