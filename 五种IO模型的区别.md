## **五种IO模型的区别** 

**阻塞I/O：**

 当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。

**非阻塞I/O：**

 在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。

**多路复用I/O（select和poll）：**

 IO多路转接是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理。其中，select只负责等，recvfrom只负责拷贝。 IO多路转接是属于阻塞IO，但可以对多个文件描述符进行阻塞监听，所以效率较阻塞IO的高。

**信号驱动I/O（SIGIO）：**

 信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。

**异步I/O（Posix.1的aio_系列函数）：**

 当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序。

**可以看出，阻塞程度：阻塞IO>非阻塞IO>多路转接IO>信号驱动IO>异步IO，效率是由低到高的**。

## select、poll、epoll的区别？

**select** 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。

**poll **本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。

**epoll **支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。



## 为什么epoll比select和poll更高效？

### **（1）减少了用户态和内核态之间文件描述符的拷贝**

***\*select创建了3个文件描述符集（fd_set）并\*\*拷贝到内核中\*\*，分别监听读、写、异常事件。内核分配相关数据结构（\*\*\*\*fd_set_bits\*\*\*\*），\*\*\*\*\*\*\*\*内核在检测到有就绪事件后，就修改用户传进来的fd_set的值以告知用户有就绪的文件描述符\*\*\*\*。将文件描述符fd_set\*\*拷贝传出到用户态\*\*并返回就绪的文件描述符的总个数。内核\*\*\*\*删除和文件描述符相关的数据结构，\*\*\*\*\*\*\*\*由于内核修改了用户传进来的fd_set文件描述符集，下次调用select前必须要重置fd_set，然后重新传给内核，\*\*\*\*\*\*\*\*内核在重新拷贝一份，重新分配数据结构。\*\*\*\*\*\*\*\*\**
**

***\**\*\*\*poll系统调用\*\*将struct pollfd结构体数组拷贝到内核中进行监听，\*\*内核分配相关数据结构\*\*poll_list,用来存储监听的文件描述符，然后调用所有fd对应的poll(将current挂到各个fd对应的设备等待队列上)，\*\*\*\*\*\*\*\*内核在检测到有就绪事件后\*\*\*\*，就修改fd对应的revents的值用来\*\*\*\*告知用户有就绪的文件描述符\*\*\*\*，而events成员保持不变，因此下次调用poll时，应用程序无需重置pollfd类型的事件集参数。将之前传入的struct pollfd结构体数组\*\*\*\*拷贝传出到用户态\*\*\*\*，并返回就绪文件描述符的总个数。内核\*\*\*\*\*\*删除和文件描述符相关的数据结构，\*\*\*\*\*\*\*\*下次调用poll需要将\*\*\*\*struct pollfd\*\*\*\*重新传给内核，\*\*\*\*\*\*\*\*内核在重新拷贝一份，重新分配数据结构。\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\****



**执行epoll_create()函数会在内核创建一颗红黑树rb_node以及就绪链表rdllist(存放已经就绪的文件描述符)，\**\*\*接着用户执行的epoll_ctl()函数将epoll_event结构体拷贝传入内核，内核会在红黑树上添加相应的结点，\*\**\*****内核将就绪的文件描述符事件复制到传入的poll_event结构体数组中返回给用户空间，系统调用在返回时\**采用mmap共享存储区\**，需要拷贝的次数大大减少。由于****epoll创建的有关文件描述符的数据结构本身就****存在于内核态中****。下一次调用epoll系统调用时，****不需要再次拷贝用户空间所要监听的文件描述符，也不需要重新构建红黑树和就绪链表等相关数据结构****，直接沿用已经存在的数据结构。**

### **（2）减少了对就绪文件描述符的遍历**

select和poll采用轮询的方式来检查文件描述符是否处于就绪状态。并且内核修改用户传进来的fd_set和pollfd结构体的成员的revents值以告知用户有文件描述符就绪，但是用户并不知道有哪些文件描述符处于就绪态，需要遍历查找就绪文件描述符，因此，应用程序索引就绪文件描述符的时间复杂度为O（n）.

**而epoll采用回调机制。在调用epoll_ctl时，已经将用户感兴趣的事件传给了内核，内核会维持一个内核事件表，记录用户感兴趣的事件，就绪事件发生时，驱动设备调用回调函数\**ep_poll_callback()\**将就绪的fd挂到rdllist上。用户调用epoll_wait时，将rdllist上就绪的文件描述符发送给用户。此时发送给用户的都是就绪的fd。因此，应用程序索引就绪文件描述符的时间复杂度为O（1）。**

### **（3）select和poll只支持LT模式，而epoll支持高效的ET模式，并且epoll还支持EPOLLONESHOT事件。**

LT模式（电平触发）：LT模式是默认的工作模式，当检测到文件描述符上有事件发生并将此事件通知给应用程序，应用程序可以不立即处理该事件，下次调用会再次响应应用程序并通知此事件。

**ET模式（边沿触发）**：当检测到文件描述符上有事件发生并将此事件通知给应用程序，应用程序必须立即处理该事件，如果没处理或者没处理完，下次调用不会再响应应用程序并通知此事件。

ET模式很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高，epoll工作在ET模式的时候，必须使用非阻塞的套接字，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

***\*即使使用ET模式，一个socket上的某个事件还是可能被触发多次\**\**，这在并发程序中就会引发一个问题。比如一个线程在读取完某个socket上的数据开始处理这些数据的时候，而在数据的处理过程中这个socket上又有新数据可读，这时另一个线程被唤醒来处理新数据，于是就出现了两个线程同时操作一个socket的局面。因此需要使用epoll的EPOLLONESHOT事件实现。对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上的一个读、写或异常事件，且只触发一次。当一个线程在处理socket时，其它线程是不可能有机会操作该socket的。注册了EPOLLONESHOT事件的socket一旦被某个线程处理完，该线程就应该\**\**立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下次可读时\**\**，其EPOLLIN事件可被触发，进而让其它线程有机会处理这个socket。使用EPOLLONESHOT事件能进一步减少可读、可写和异常事件的被触发的次数。\****





## **无论哪种情况下，epoll都比select和poll高效吗？**

***\*epoll适用于\*\*连接较多，活动数量较少\*\*的情况。\**** 
(1)epoll为了实现返回就绪的文件描述符，维护了一个红黑树和好多个等待队列，内核开销很大。如果此时监听了很少的文件描述符，底层的开销会得不偿失；

(2)epoll中注册了回调函数，当有事件发生时，服务器设备驱动调用回调函数将就绪的fd挂在rdllist上，如果有很多的活动，同一时间需要调用的回调函数数量太多，服务器压力太大。

***\*select和poll适用于\*\*连接较少\*\*的情况。\**** 
当select和poll上监听的fd数量较少，内核通知用户现在有就绪事件发生，应用程序判断当前是哪个fd就绪所消耗的时间复杂度就会大大减小。



